<script>
const timeoutMap = new WeakMap<Element, number>()

async function handleCodeCopyClick(e: MouseEvent) {
  if (!(e.target instanceof Element)) {
    return
  }

  const button = e.target.closest('.code-copy-button')
  if (!button) {
    return
  }

  let codeElement: HTMLElement | null = null

  // 检查是否在折叠的代码块中
  const codeWrapper = button.closest('.code-collapse-wrapper')

  if (codeWrapper) {
    // 如果在折叠代码块中，优先获取完整代码
    const fullCodeElement = codeWrapper.querySelector('.code-collapse-full pre code') as HTMLElement
    const previewCodeElement = codeWrapper.querySelector('.code-collapse-preview pre code') as HTMLElement

    // 优先使用完整代码，如果没有则使用预览代码
    codeElement = fullCodeElement || previewCodeElement || null
  }
  else {
    // 如果不在折叠代码块中，使用原来的逻辑
    const element = button.parentElement?.querySelector('pre > code')
    codeElement = element as HTMLElement | null
  }

  const codeText = codeElement?.textContent ?? ''
  if (!codeElement || !codeText) {
    return
  }

  // Copy text to clipboard
  try {
    await navigator.clipboard.writeText(codeText)
  }
  catch (error) {
    console.error('[CodeCopyButton] Failed to copy:', error)
    return
  }

  // Add copied state
  button.classList.add('copied')

  // Clear existing timeout to prevent state flickering
  const existingTimeout = timeoutMap.get(button)
  if (existingTimeout) {
    clearTimeout(existingTimeout)
  }

  // Reset state after 1.5s
  const timeoutId = window.setTimeout(() => {
    button.classList.remove('copied')
    timeoutMap.delete(button)
  }, 1500)

  timeoutMap.set(button, timeoutId)
}

document.addEventListener('click', handleCodeCopyClick)
</script>
